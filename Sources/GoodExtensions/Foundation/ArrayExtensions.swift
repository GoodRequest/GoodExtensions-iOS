//
//  Array.swift
//
//  Created by Dominik Pethö on 4/30/19.
//  Copyright © 2019 GoodRequest. All rights reserved.
//

import Foundation

@available(*, deprecated, message: "This extension is deprecated and marked for removal")
extension Collection where Self: GRCompatible { }

@available(*, deprecated, message: "This extension is deprecated and marked for removal")
public extension GRActive where Base: Collection {

    /// Returns array of elements where between each element will be inserted element, provided in parameter.
    /// - Parameter element: The element to insert
    /// - Returns: Returns array of elements separated by given element
    func separated(by element: Base.Element) -> [Base.Element] {
        return Array(base.map { [$0] }.joined(separator: [element]))
    }

    /// Checks if array constains item with given index.
    /// - Parameter index: The index of element in array
    /// - Returns: Boolean result whether array containts item with specified index or not.
    func contains(index: Int) -> Bool {
        // swiftlint:disable force_cast
        return (base.startIndex..<base.endIndex).contains(index as! Base.Index)
        // swiftlint:enable force_cast
    }

    /// True if array contains elements, otherwise false
    var hasItems: Bool { !base.isEmpty }

}

@available(*, deprecated, message: "This extension is deprecated and marked for removal")
extension Array: GRCompatible {}

public extension Array {

    /// Creates an array containing this array.
    ///
    /// Can be used in content factories for UIKit as follows:
    /// ```swift
    /// return banners
    ///     .discardEmpty()?
    ///     .map { Item.banner($0) }
    ///     .toArray()
    ///     .map { Section.banners($0, skeleton: false) } ?? []
    /// ```
    /// - Returns: Two-dimensional array with single element that is this array.
    func toArray() -> [Self] {
        [self]
    }
    
    /// Appends contents of this array to the end of another array
    /// - Parameter other: Mutable array where the content should be appended
    func appendTo(_ other: inout Array) {
        other.append(contentsOf: self)
    }
    
    /// Replace empty array `[]` with `nil`
    /// - Returns: `nil` when caller is empty, otherwise unmodified array
    func discardEmpty() -> Self? {
        return isEmpty ? nil : self
    }
    
    /// Replaces array with nil unless the condition is true
    /// - Parameter condition: condition to check
    /// - Returns: `nil` when condition is false
    func `if`(_ condition: Supplier<Bool>) -> Self? {
        return condition() ? self : nil
    }
    
    /// Prepends another array at the beginning of this array
    /// - Parameter otherArray: array to prepend
    /// - Returns: the other array, with contents of this array prepended at the beginning
    func prepending(_ otherArray: Array<Element>?) -> Self {
        return (otherArray ?? []) + self
    }
    
    /// Appends another array to the end of this array
    /// - Parameter otherArray: array to append
    /// - Returns: this array, with contents of another array appended to the end
    func appending(_ otherArray: Array<Element>?) -> Self {
        return self + (otherArray ?? [])
    }

    /// Generates an array by invoking an element supplier `count`-times.
    ///
    /// This function is different from ``init(repeating:count:)``, because it can provide a unique element 
    /// each time the supplier is invoked. It is useful when generating an array of reference types.
    /// - Parameters:
    ///   - elementSupplier: Supplier that gets invoked for generating every element in the resulting array
    ///   - count: Expected number of repeated elements in the generated array
    /// - Returns: Array with `count` elements generated by invoking the `elementSupplier` closure.
    static func repeating(_ elementSupplier: Supplier<Element>, count: Int) -> Self {
        var result: [Element] = []
        for _ in 0..<count { result.append(elementSupplier()) }
        return result
    }

    /// No-crash access to indexed array element.
    subscript(safe index: Int) -> Element? {
        return self.indices.contains(index) ? self[index] : nil
    }

}

public extension Array where Element: Hashable {
    
    /// Removes duplicated elements in this array in order that they are currently in.
    /// First element is kept, every other matching element is removed.
    /// - Returns: Array with duplicate elements removed.
    func removingDuplicates() -> [Element] {
        var addedDict = [Element: Bool]()

        return filter {
            addedDict.updateValue(true, forKey: $0) == nil
        }
    }

}
